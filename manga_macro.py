import time
import json
import os
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import random
from config import start_url, scroll_time, comment_on, comment_text, comments_need,comments_ready,mine_needed, after_scroll_time, scroll_mode
from datetime import datetime

class MangaParser:
    def __init__(self, headless=False):
        self.chrome_options = Options()
        
        if headless:
            self.chrome_options.add_argument("--headless")
        
        self.chrome_options.add_argument("--disable-blink-features=AutomationControlled")
        self.chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        self.chrome_options.add_experimental_option('useAutomationExtension', False)
        self.chrome_options.add_argument("--disable-dev-shm-usage")
        self.chrome_options.add_argument("--no-sandbox")
        self.chrome_options.add_argument("--window-size=1920,1080")
        
        self.chrome_options.add_argument("--blink-settings=imagesEnabled=true")
        self.chrome_options.add_experimental_option("prefs", {
            "profile.managed_default_content_settings.images": 1,
            "profile.default_content_setting_values.notifications": 2
        })
        self.chrome_options.set_capability("pageLoadStrategy", "none")  
        
        self.driver = None
        self.cookies_file = "manga_cookies.json"
        self.comments_count = comments_ready
        self.max_comments_per_session = comments_need
        
        self.candy_times = []
        self.candy_count = 0
        self.pumpkin_count = 0

    def update_config_url(self, new_url):
        try:
            with open('config.py', 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            for i, line in enumerate(lines):
                if line.startswith('start_url ='):
                    lines[i] = f"start_url = '{new_url}'\n"
                    break
            
            with open('config.py', 'w', encoding='utf-8') as f:
                f.writelines(lines)
            
            print(f"‚úÖ –ö–æ–Ω—Ñ–∏–≥ –æ–±–Ω–æ–≤–ª–µ–Ω: {new_url}")
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥–∞: {e}")

    def setup_driver(self):
        self.driver = webdriver.Chrome(options=self.chrome_options)
        self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        self.driver.set_page_load_timeout(1)
        self.driver.set_script_timeout(10)
        self.load_cookies()

    def save_cookies(self): 
        if self.driver:
            cookies = self.driver.get_cookies()
            with open(self.cookies_file, 'w') as f:
                json.dump(cookies, f)
        print('–ö—É–∫–∏ —Ñ–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã')

    def retry_on_timeout(self, func, max_attempts=3, delay=5, func_name=""):
        for attempt in range(max_attempts):
            try:
                return func()
            except Exception as e:
                if "timed out" in str(e) or "Read timed out" in str(e) or "TimeoutException" in str(e):
                    print(f"‚ö†Ô∏è –¢–∞–π–º–∞—É—Ç {func_name} (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{max_attempts}): {e}")
                    if attempt < max_attempts - 1:
                        time.sleep(delay)
                        continue
                else:
                    raise e
        print(f"‚ùå –ü—Ä–æ–ø—É—Å–∫–∞–µ–º {func_name} –ø–æ—Å–ª–µ {max_attempts} –Ω–µ—É–¥–∞—á–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫")
        return None

    def load_cookies(self):
        print('–í—ã–≥—Ä—É–∂–∞—é –∫—É–∫–∏ —Ñ–π–ª—ã...')
        if os.path.exists(self.cookies_file):
            try:
                self.driver.get("https://mangabuff.ru")
                with open(self.cookies_file, 'r') as f:
                    cookies = json.load(f)
                for cookie in cookies:
                    self.driver.add_cookie(cookie)
                time.sleep(2)
            except Exception as e:
                print(f"Error loading cookies: {e}")
        print('–ö—É–∫–∏ —Ñ–∞–π–ª—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã')

    def wait_fixed_cooldown(self, seconds=5):
        print(f'–ñ–¥—É {seconds} —Å–µ–∫—É–Ω–¥ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫—É–ª–¥–∞—É–Ω–∞')
        time.sleep(seconds)
        print('–ö—É–ª–¥–∞—É–Ω –∑–∞–≤–µ—Ä—à–µ–Ω')

    def navigate_with_cooldown(self, url, cooldown=5):
        try:
            print(f'–ü–µ—Ä–µ—Ö–æ–∂—É –ø–æ URL: {url}')
            self.driver.set_page_load_timeout(2)
            self.driver.get(url)
        except Exception as e:
            print(f'–ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Ç–∞–π–º–∞—É—Ç –∑–∞–≥—Ä—É–∑–∫–∏: {e}')
        finally:
            self.wait_fixed_cooldown(cooldown)

    def refresh_with_cooldown(self, cooldown=3):
        try:
            print('–û–±–Ω–æ–≤–ª—è—é —Å—Ç—Ä–∞–Ω–∏—Ü—É')
            self.driver.set_page_load_timeout(cooldown)
            self.driver.refresh()
        except Exception as e:
            print(f'–ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Ç–∞–π–º–∞—É—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è: {e}')
        finally:
            self.wait_fixed_cooldown(cooldown)

    def smooth_scroll(self, duration=30, after_scroll_time=15, mode=1):
        if mode == 1:
            start_time = time.time()
            
            print(f'–°–∫—Ä–æ–ª—é —Å—Ç—Ä–∞–Ω–∏—Ü—É {duration} —Å–µ–∫—É–Ω–¥')
            
            while time.time() - start_time < duration:
                cycle_start = time.time()
                
                self.driver.execute_script("window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'});")
                time.sleep(0.5)
                self.enhanced_check_buttons()
                
                self.driver.execute_script("window.scrollTo({top: 0, behavior: 'smooth'});")
                time.sleep(0.5)
                self.enhanced_check_buttons()
                
                self.driver.execute_script("window.scrollTo({top: document.body.scrollHeight, behavior: 'smooth'});")
                time.sleep(0.5)
                self.enhanced_check_buttons()
                
                cycle_elapsed = time.time() - cycle_start
                if cycle_elapsed < 5:
                    time.sleep(5 - cycle_elapsed)
            
            print(f'–°—Ç—Ä–∞–Ω–∏—Ü–∞ –¥–æ—Å–∫—Ä–æ–ª–µ–Ω–∞, –ø—Ä–æ–≤–µ—Ä—è—é –∫–æ–Ω—Ñ–µ—Ç—ã {after_scroll_time} —Å–µ–∫—É–Ω–¥')
            
            final_check_start = time.time()
            while time.time() - final_check_start < after_scroll_time:
                time.sleep(1)
                self.enhanced_check_buttons()
            
            print(f'–ù–∞–ª–∏—á–∏–µ –∫–æ–Ω—Ñ–µ—Ç—ã –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ')

        elif mode == 2:

            start_time = time.time()
            viewport_height = self.driver.execute_script("return window.innerHeight")
            step_time = 2.0

            scroll_iteration = 0
            print(f'–°–∫—Ä–æ–ª—é —Å—Ç—Ä–∞–Ω–∏—Ü—É {duration} —Å–µ–∫—É–Ω–¥')
            while time.time() - start_time < duration:
                scroll_iteration += 1

                current_position = self.driver.execute_script("return window.pageYOffset;")
                current_total_height = self.driver.execute_script("return document.body.scrollHeight")
                remaining_height = current_total_height - current_position - viewport_height

                if remaining_height <= 0:
                    break

                time_elapsed = time.time() - start_time
                time_left = duration - time_elapsed

                if time_left <= 0:
                    break

                current_pixels_per_second = remaining_height / time_left if time_left > 0 else remaining_height
                scroll_down_distance = current_pixels_per_second * step_time
                scroll_down_distance = max(100, min(scroll_down_distance, 800))

                if scroll_down_distance > 0:
                    self.driver.execute_script(f"""
                        window.scrollBy({{
                            top: {scroll_down_distance},
                            left: 0,
                            behavior: 'smooth'
                        }});
                    """)
                    time.sleep(1)
            print(f'–°—Ç—Ä–∞–Ω–∏—Ü–∞ –¥–æ—Å–∫—Ä–æ–ª–µ–Ω–∞, –ø—Ä–æ–≤–µ—Ä—è—é –∫–æ–Ω—Ñ–µ—Ç—ã {after_scroll_time} —Å–µ–∫—É–Ω–¥')
            while time.time() - start_time < duration + after_scroll_time:
                time.sleep(1)
                self.enhanced_check_buttons()
            print(f'–ù–∞–ª–∏—á–∏–µ –∫–æ–Ω—Ñ–µ—Ç—ã –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ')

    def record_candy_found(self, candy_type="candy"):
        current_time = datetime.now()
        self.candy_times.append(current_time)
        
        if candy_type == "pumpkin":
            self.pumpkin_count += 1
            self.candy_count += 3
            print(f"üéÉ –ù–∞–π–¥–µ–Ω–∞ —Ç—ã–∫–≤–∞! +3 –∫–æ–Ω—Ñ–µ—Ç—ã (–≤—Å–µ–≥–æ –∫–æ–Ω—Ñ–µ—Ç: {self.candy_count})")
        else:
            self.candy_count += 1
            print(f"üç¨ –ù–∞–π–¥–µ–Ω–∞ –∫–æ–Ω—Ñ–µ—Ç–∞! (–≤—Å–µ–≥–æ –∫–æ–Ω—Ñ–µ—Ç: {self.candy_count})")
        
        if len(self.candy_times) > 1:
            self.print_candy_statistics()

    def print_candy_statistics(self):
        if len(self.candy_times) < 2:
            return
            
        total_seconds = 0
        for i in range(1, len(self.candy_times)):
            time_diff = (self.candy_times[i] - self.candy_times[i-1]).total_seconds()
            total_seconds += time_diff
        
        avg_time = total_seconds / (len(self.candy_times) - 1)
        print(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: –Ω–∞–π–¥–µ–Ω–æ {self.candy_count} –∫–æ–Ω—Ñ–µ—Ç ({self.pumpkin_count} —Ç—ã–∫–≤), —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –º–µ–∂–¥—É –∫–æ–Ω—Ñ–µ—Ç–∞–º–∏: {avg_time:.1f} —Å–µ–∫")

    def enhanced_check_buttons(self):
        self.check_event_ball_buttons()
        self.check_event_bag_buttons()
    
    def check_event_ball_buttons(self):
        try:
            selectors = [
                "[class*='event-gift-ball']",
                "div[class*='event-gift-ball']"
            ]
            
            candy_found = False
            for selector in selectors:
                try:
                    buttons = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    for button in buttons:
                        try:
                            class_name = button.get_attribute('class')
                            if 'event-gift-ball--collected' in class_name:
                                continue
                                
                            self.driver.execute_script("""
                                var element = arguments[0];
                                element.style.display = 'block';
                                element.style.visibility = 'visible';
                                element.style.opacity = '1';
                                element.style.pointerEvents = 'auto';
                            """, button)
                            
                            script = """
                            var element = arguments[0];
                            
                            function triggerEvent(element, eventType) {
                                var event = new MouseEvent(eventType, {
                                    'view': window,
                                    'bubbles': true,
                                    'cancelable': true,
                                    'clientX': element.getBoundingClientRect().left + element.offsetWidth / 2,
                                    'clientY': element.getBoundingClientRect().top + element.offsetHeight / 2,
                                    'button': 0,
                                    'buttons': 1
                                });
                                element.dispatchEvent(event);
                            }
                            
                            triggerEvent(element, 'mouseover');
                            triggerEvent(element, 'mousedown');
                            triggerEvent(element, 'mouseup');
                            triggerEvent(element, 'click');
                            
                            if (window.jQuery) {
                                var $elem = jQuery(element);
                                if ($elem) {
                                    $elem.trigger('mouseenter');
                                    $elem.trigger('mousedown');
                                    $elem.trigger('mouseup');
                                    $elem.trigger('click');
                                }
                            }
                            
                            return 'Event triggered';
                            """
                            
                            self.driver.execute_script(script, button)
                            time.sleep(2)
                            
                            if not candy_found:
                                self.record_candy_found("candy")
                                candy_found = True
                            
                        except Exception as e:
                            pass
                            
                except Exception as e:
                    continue
                    
        except Exception as e:
            print("ball error")
            pass

    def check_event_bag_buttons(self):
        try:
            selectors = [
                "[class*='event-bag']",
                "div[class*='event-bag']",
                ".event-bag"
            ]
            
            candy_found = False
            for selector in selectors:
                try:
                    bags = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    
                    for bag in bags:
                        try:
                            class_name = bag.get_attribute('class')
                            is_displayed = bag.is_displayed()
                            
                            for click_count in range(10):
                                try:
                                    script = """
                                    var element = arguments[0];
                                    var clickCount = arguments[1];
                                    
                                    var event = new MouseEvent('click', {
                                        view: window,
                                        bubbles: true,
                                        cancelable: true,
                                        clientX: element.getBoundingClientRect().left + element.offsetWidth / 2,
                                        clientY: element.getBoundingClientRect().top + element.offsetHeight / 2,
                                        button: 0
                                    });
                                    
                                    element.dispatchEvent(event);
                                    
                                    if (window.jQuery) {
                                        jQuery(element).trigger('click');
                                    }
                                    
                                    return 'Click ' + clickCount + ' triggered';
                                    """
                                    
                                    self.driver.execute_script(script, bag, click_count + 1)
                                    time.sleep(0.3)
                                    
                                    if not candy_found:
                                        self.record_candy_found("candy")
                                        candy_found = True
                                    
                                except Exception as e:
                                    pass
                            
                            time.sleep(2)
                            break
                            
                        except Exception as e:
                            pass
                            
                except Exception as e:
                    continue
                    
        except Exception as e:
            print('bag error')
            pass

    def check_pumpkin_on_event_page(self):
        try:
            pumpkin_selectors = [
                "[class*='pumpkin']",
                "[class*='halloween']",
                ".event-game__item"
            ]
            
            for selector in pumpkin_selectors:
                elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                if elements:
                    return True
            return False
        except:
            return False

    def post_comment(self, comment_text="—Å–ø–∞–∏—Å–±–æ –∑–∞ –≥–ª–∞–≤—É"):
        if self.comments_count >= self.max_comments_per_session:
            print('–ù–∞–ø–∏—Å–∞–Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤')
            return False

        try:
            print(f'–ü–∏—à—É –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π "{comment_text}"')
            time.sleep(3)
            self.refresh_with_cooldown(3)
            comment_button_selectors = [
                ".reader-menu__item--comment",
                "[class*='comment']",
                ".reader-menu__item i.icon-comment"
            ]
            
            comment_button = None
            for selector in comment_button_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    for element in elements:
                        if element.is_displayed():
                            comment_button = element
                            break
                    if comment_button:
                        break
                except:
                    continue
            
            if not comment_button:
                print("–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤")
                return False
                
            self.driver.execute_script("arguments[0].click();", comment_button)
            time.sleep(3)
                        
            spoiler_selectors = [
                ".comments__actions-btn--spoiler",
                "[class*='spoiler']",
                "button[title*='—Å–ø–æ–π–ª–µ—Ä']"
            ]
            
            spoiler_button = None
            for selector in spoiler_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    for element in elements:
                        if element.is_displayed():
                            spoiler_button = element
                            break
                    if spoiler_button:
                        break
                except:
                    continue
            
            if spoiler_button:
                self.driver.execute_script("arguments[0].click();", spoiler_button)
                time.sleep(1)
            
            textarea_selectors = [
                ".comments__send-form textarea",
                "textarea[placeholder*='–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π']",
                "textarea.comments__textarea"
            ]
            
            comment_textarea = None
            for selector in textarea_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    for element in elements:
                        if element.is_displayed():
                            comment_textarea = element
                            break
                    if comment_textarea:
                        break
                except:
                    continue
            
            if not comment_textarea:
                print("–ù–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–ª–µ –¥–ª—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è")
                return False
                
            comment_textarea.clear()
            comment_textarea.send_keys(comment_text)
            time.sleep(1)
            
            send_selectors = [
                ".comments__send-btn",
                "button[type='submit']",
                "input[type='submit']",
                "button:contains('–û—Ç–ø—Ä–∞–≤–∏—Ç—å')"
            ]
            
            send_button = None
            for selector in send_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    for element in elements:
                        if element.is_displayed() and "–æ—Ç–ø—Ä–∞–≤–∏—Ç—å" in element.text.lower():
                            send_button = element
                            break
                    if send_button:
                        break
                except:
                    continue
            
            if send_button:
                self.driver.execute_script("arguments[0].click();", send_button)
                time.sleep(2)
            
            close_selectors = [
                ".reader-comments__close",
                ".modal__close",
                "button[aria-label*='close']",
                "button:contains('–ó–∞–∫—Ä—ã—Ç—å')"
            ]
            
            close_button = None
            for selector in close_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    for element in elements:
                        if element.is_displayed():
                            close_button = element
                            break
                    if close_button:
                        break
                except:
                    continue
            
            if close_button:
                self.driver.execute_script("arguments[0].click();", close_button)
            
            self.comments_count += 1
            print(f"‚úÖ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –Ω–∞–ø–∏—Å–∞–Ω ({self.comments_count}/{self.max_comments_per_session})")
            time.sleep(2)
            return True

        except Exception as e:
            print(f'comment_error: {e}')
            return False


    def go_to_mine(self):
        try:
            print('–û—Ç–ø—Ä–∞–≤–ª—è—é—Å—å –≤ —à–∞—Ö—Ç—É')
            current_url = self.driver.current_url
            
            profile_selectors = [
                ".header-profile.dropdown__trigger",
                ".user-avatar",
                "[class*='profile']",
                "[class*='dropdown']"
            ]
            
            profile_button = None
            for selector in profile_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    for element in elements:
                        if element.is_displayed():
                            profile_button = element
                            break
                    if profile_button:
                        break
                except:
                    continue
            
            if not profile_button:
                print("–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è")
                return False
                
            self.driver.execute_script("arguments[0].click();", profile_button)
            time.sleep(2)
            
            mine_selectors = [
                "a[href='/mine']",
                "a[href*='mine']",
                "a:contains('–®–∞—Ö—Ç–∞')",
                "a:contains('—à–∞—Ö—Ç–∞')"
            ]
            
            mine_link = None
            for selector in mine_selectors:
                try:
                    elements = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    for element in elements:
                        if element.is_displayed() and ("—à–∞—Ö—Ç" in element.text.lower() or "mine" in element.text.lower()):
                            mine_link = element
                            break
                    if mine_link:
                        break
                except:
                    continue
            
            if not mine_link:
                print("–ù–µ –Ω–∞–π–¥–µ–Ω–∞ —Å—Å—ã–ª–∫–∞ –Ω–∞ —à–∞—Ö—Ç—É")
                return False
                
            self.driver.execute_script("arguments[0].click();", mine_link)
            time.sleep(3)
            
            if "mine" not in self.driver.current_url:
                print("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–π—Ç–∏ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É —à–∞—Ö—Ç—ã")
                return False
            
            hits_left = self.check_mine_hits()
            print(f'–ù—É–∂–Ω–æ –≤—Å–∫–æ–ø–∞—Ç—å –µ—â–µ {hits_left} —Ä–∞–∑')
            
            while hits_left > 0:
                success = self.click_mine_button()
                if success:
                    hits_left -= 1
                time.sleep(0.5)
                
                if hits_left % 5 == 0:
                    hits_left = self.check_mine_hits()

            print('–®–∞—Ö—Ç–∞ –≤—Å–∫–æ–ø–∞–Ω–∞')
            
            self.navigate_with_cooldown(current_url, 3)
            return True

        except Exception as e:
            print(f'mine error: {e}')
            return False

    def click_mine_button(self):
        try:
            mine_button = self.driver.find_element(By.CSS_SELECTOR, ".main-mine__game-tap")
            mine_button.click()
            time.sleep(0.1)  
            return True
        except:
            return False

    def check_mine_hits(self):
        try:
            hits_element = self.driver.find_element(By.CSS_SELECTOR, ".main-mine__game-hits-left")
            hits_text = hits_element.text.strip()
            return int(hits_text)
        except:
            return 0

    def go_to_next_page(self):
        try:
            print('–ü–µ—Ä–µ–ª–∏—Å—Ç—ã–≤–∞—é —Å—Ç—Ä–∞–Ω–∏—Ü—É')
            next_button = WebDriverWait(self.driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "a.navigate-button i.icon-new-arrow-next"))
            )
            
            link = next_button.find_element(By.XPATH, "./..")
            link.click()
            print('–°—Ç—Ä–∞–Ω–∏—Ü–∞ –ø–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç–∞')
            return True
                
        except Exception as e:
            print('next page error')
            return False

    def quick_scroll_to_bottom(self):
        try:
            self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
            time.sleep(1)
            return True
        except:
            return False

    def parse_manga(self, start_url, scroll_duration=30, comment_text="—Å–ø–∞–∏—Å–±–æ –∑–∞ –≥–ª–∞–≤—É", after_scroll_time=15, scroll_mode=1):
        try:
            self.setup_driver()
            current_url = start_url
            mine_flag = False
            
            current_day = datetime.now().day
            day_changed = False

            while True:
                now = datetime.now()
                if now.day != current_day:
                    print("üîÑ –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ —Å–º–µ–Ω–∞ –¥–Ω—è! –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫–∏...")
                    current_day = now.day
                    mine_flag = False 
                    self.comments_count = 0  
                    day_changed = True

                cycle_start_time = datetime.now()
                print(f"–ù–∞—á–∞–ª–æ —Ü–∏–∫–ª–∞ - {cycle_start_time}")
                print(f"üìä –í—Å–µ–≥–æ –Ω–∞–π–¥–µ–Ω–æ –∫–æ–Ω—Ñ–µ—Ç: {self.candy_count}")

                if day_changed:
                    print("üéâ –°—á–µ—Ç—á–∏–∫–∏ —Å–±—Ä–æ—à–µ–Ω—ã –¥–ª—è –Ω–æ–≤–æ–≥–æ –¥–Ω—è!")
                    day_changed = False
                
                self.navigate_with_cooldown(current_url, 5)
                
                if self.comments_count < self.max_comments_per_session and comment_on:
                    self.refresh_with_cooldown(3)
                    self.post_comment(comment_text)

                elif not mine_flag and mine_needed:   
                    mine_result = self.go_to_mine()
                    if mine_result is not None:
                        mine_flag = mine_result

                self.retry_on_timeout(
                    lambda: self.smooth_scroll(scroll_duration, after_scroll_time, mode=scroll_mode),
                    func_name="—Å–∫—Ä–æ–ª–ª–∏–Ω–≥ —Å—Ç—Ä–∞–Ω–∏—Ü—ã"
                )

                next_page_success = False
                a = 3
                for attempt in range(a):
                    self.quick_scroll_to_bottom()
                    self.enhanced_check_buttons()
                    
                    next_result = self.retry_on_timeout(
                        lambda: self.go_to_next_page(),
                        func_name="–ø–µ—Ä–µ—Ö–æ–¥ –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É"
                    )
                    time.sleep(5)
                    if next_result:
                        self.refresh_with_cooldown(3)
                        next_page_success = True
                        break
                    print(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É, –ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{a}")
                    time.sleep(2)

                if not next_page_success:
                    break

                new_url = self.driver.current_url
                if new_url != current_url:
                    self.update_config_url(new_url)
                    current_url = new_url

                self.wait_fixed_cooldown(3)
                
        except Exception as e:
            print(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        finally:
            if self.candy_count > 0:
                print(f"üéØ –§–ò–ù–ê–õ–¨–ù–ê–Ø –°–¢–ê–¢–ò–°–¢–ò–ö–ê: –Ω–∞–π–¥–µ–Ω–æ {self.candy_count} –∫–æ–Ω—Ñ–µ—Ç ({self.pumpkin_count} —Ç—ã–∫–≤)")
                if len(self.candy_times) > 1:
                    total_seconds = (self.candy_times[-1] - self.candy_times[0]).total_seconds()
                    avg_time = total_seconds / (len(self.candy_times) - 1)
                    print(f"üìä –°—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –º–µ–∂–¥—É –∫–æ–Ω—Ñ–µ—Ç–∞–º–∏: {avg_time:.1f} —Å–µ–∫")
            exit

    def login_only(self):
        self.setup_driver()
        self.driver.get("https://mangabuff.ru")
        input("Press Enter after login...")
        self.save_cookies()
        self.driver.quit()

def main():

    print("1 - Login only")
    print("2 - Full parsing")
    
    choice = input("Enter mode (1 or 2): ").strip()
    
    parser = MangaParser(headless=False)
    
    if choice == "1":
        parser.login_only()
    elif choice == "2":
        START_URL = start_url
        SCROLL_DURATION = scroll_time
        COMMENT_TEXT = comment_text
        
        parser.parse_manga(
            start_url=START_URL,
            scroll_duration=SCROLL_DURATION,
            comment_text=COMMENT_TEXT,
            after_scroll_time=after_scroll_time,
            scroll_mode=scroll_mode
        )
    else:
        print("Invalid choice")

if __name__ == "__main__":
    main()
